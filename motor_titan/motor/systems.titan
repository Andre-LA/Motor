local bit_ids  = import 'motor.bit_ids'
local storages = import 'motor.storages'
local entities = import 'motor.entities'

local function combine_arrays (t1: {value}, t2: {value}): {value}
  local new_table: {value} = {}

  for i=1, #t1 do

    new_table[i] = t1[i]
  end

  local new_table_len = #new_table

  for i=1, #t2 do

    new_table[new_table_len+i] = t2[i]
  end

  return new_table
end

record SystemData
  --all_reads : { {integer} }
  --all_writes: { {integer} }
  --all_needs : { {integer} }

  --component_reads : { {integer} }
  --component_writes: { {integer} }
  component_needs : { {integer} }

  --simple_state_content_reads : { {integer} }
  --simple_state_content_writes: { {integer} }
  simple_state_content_needs : { {integer} }

  --all_bit_filter: {integer}
  component_state_content_bit_filter: {integer}
  --simple_state_content_bit_filter: {integer}

  components_ids_to_iterate: { {storages.Id} }
end

function new_init_system_data(
  required_simple_state_content: {{{integer}}}, -- {{{integer}}} = array of arrays of bit_ids (aka array of integers)
  required_compnt_state_content: {{{integer}}}
): SystemData


  local compnt_state_content_reads : {{integer}} = required_compnt_state_content[1]

  local compnt_state_content_writes: {{integer}} = required_compnt_state_content[2]

  local compnt_state_content_needs : {{integer}} = combine_arrays(compnt_state_content_reads, compnt_state_content_writes)

  local simple_state_content_reads : {{integer}} = required_simple_state_content[1]

  local simple_state_content_writes: {{integer}} = required_simple_state_content[2]

  local simple_state_content_needs : {{integer}} = combine_arrays(simple_state_content_reads, simple_state_content_writes)


  -- local all_needs = combine_arrays(simple_state_content_needs , compnt_state_content_needs)


  local system_data: SystemData = {
    --all_reads  = combine_arrays(simple_state_content_reads , compnt_state_content_reads),
    --all_writes = combine_arrays(simple_state_content_writes, compnt_state_content_writes),
    --all_needs  = all_needs,

    --component_reads  = compnt_state_content_reads,
    --component_writes = compnt_state_content_writes,
    component_needs  = compnt_state_content_needs,

    --simple_state_content_reads  = simple_state_content_reads,
    --simple_state_content_writes = simple_state_content_writes,
    simple_state_content_needs  = simple_state_content_needs,

    --all_bit_filter = bit_ids.new_bit_filter(all_needs),
    component_state_content_bit_filter = bit_ids.new_bit_filter(compnt_state_content_needs),
    --simple_state_content_bit_filter = bit_ids.new_bit_filter(simple_state_content_needs),

    components_ids_to_iterate = {}
  }

  return system_data
end

function prepare(system_data: SystemData, entities_storage: storages.Storage)
  if storages.delete_dead_entries(entities_storage) then
    update_components_ids_to_iterate(system_data, entities_storage.entries)
  end
end

--

function update_components_ids_to_iterate(system_data: SystemData, entities_entries: {storages.Entry})
  local components_ids_to_system: { {storages.Id} } = {}

  -- for each entity entry
  for entities_i = 1, #entities_entries do
    local entity_entry = entities_entries[entities_i]

    -- if entry is valid and alive
    if entity_entry and entity_entry.is_alive then
      local entity: entities.EntityData = entity_entry.content

      -- does this entity contains the required components?
      if bit_ids.contains_bit_ids(entity.state_content_bit_filter, system_data.component_state_content_bit_filter) then

        -- then we will get the ids of the associated components
        local components_tuple: {storages.Id} = {}
        local components_tuple_n = 0

        -- for each state content bit_id needs of a system_data
        for system_needs_i = 1, #system_data.component_needs do

          local _break = false
          -- for each associated state_content bit_id of an entity
          for entity_associated_state_content_bit_ids_i=1, #entity.associated_state_content_bit_ids do

            if not _break then
              local associated_state_content_bit_id
                = entity.associated_state_content_bit_ids[entity_associated_state_content_bit_ids_i]

              -- is this associated_state_content_bit_id one of the components_ids that the system_data needs?
              if bit_ids.equals(associated_state_content_bit_id, system_data.component_needs[system_needs_i]) then
                -- insert associated component entry id in components_tuple
                -- index of associated components and associated state_content ids is the same :)
                  components_tuple_n = components_tuple_n + 1
                  components_tuple[components_tuple_n]
                    = entity.associated_components_entries_ids[entity_associated_state_content_bit_ids_i]

                _break = true -- break not yet implemented in Titan
              end
            end
          end
        end

        if #components_tuple > 0 then
          components_ids_to_system[#components_ids_to_system+1] = components_tuple
        end
      end
    end
  end

  system_data.components_ids_to_iterate = components_ids_to_system
end

--

function SystemData:update_components_ids_to_iterate(entities_entries: {storages.Entry})
  update_components_ids_to_iterate(self, entities_entries)
end

function SystemData:prepare(entities_storage: storages.Storage)
  prepare(self, entities_storage)
end
