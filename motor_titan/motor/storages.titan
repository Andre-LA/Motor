record Id
  index: integer
  generation: integer
end

record Entry
  id: Id
  content: value
  is_alive: boolean
end

record Storage
  free_ids_len: integer
  free_ids: {Id}
  entries: {Entry}
  -- TODO: entries_ids = {}, and remove ids fields in entries
  -- TODO: alive_ids = {}, and remove alive fields in entries
end

function new_init_storage(): Storage
  local storage: Storage = {
    free_ids_len = 0,
    free_ids = {},
    entries = {}
  }

  return storage
end

--

function new_entry(storage: Storage, new_entry_content: value): Id
  -- is there any free id?
  if storage.free_ids_len > 0 then
    -- get last free id
    local recycled_id = storage.free_ids[storage.free_ids_len]

    -- increment generation of the recycled id
    recycled_id.generation = recycled_id.generation + 1

    -- remove last free id
    storage.free_ids[#storage.free_ids] = nil

    -- decrement free ids lenght
    storage.free_ids_len = storage.free_ids_len - 1

    local new_entry: Entry = {id = recycled_id, content = new_entry_content, is_alive = true}

    -- new entry
    storage.entries[new_entry.id.index] = new_entry

    -- return the id of the new entry
    return recycled_id
  else -- no free id, so, allocate a new entry
    -- create new id data and entry data
    local new_id: Id = {index = #storage.entries + 1, generation = 1}
    local new_entry: Entry = {id = new_id, content = new_entry_content, is_alive = true}

    -- apply new entry in the last index of storage's entries
    -- (new_id[1] is the last index already)
    storage.entries[new_entry.id.index] = new_entry

    -- return the id of the new entry
    return new_id
  end
end

function get_entry(storage: Storage, id: Id): Entry
  -- get entry
  local entry = storage.entries[id.index]

  -- if entry.id.generation ~= id.generation then error() end
  -- should only return entry if generation is equal, but I don't know how to to this

  return entry
end

function kill_entry(storage: Storage, id:Id)
  storage:get_entry(id).is_alive = false
end

function delete_dead_entries(storage: Storage): boolean
  local some_entry_was_deleted = false

  -- iterate entries
  local entries = storage.entries
  for i = 1, #entries do
    -- if this entry isn't alive
    if entries[i] and not entries[i].is_alive then
      storage:delete_entry(entries[i].id)
      some_entry_was_deleted = true
    end
  end

  return some_entry_was_deleted
end

function delete_entry(storage: Storage, id: Id)
  -- delete entry
  -- (I don't know if this is possible in Titan) storage.entries[id.index] = false

  -- add a new free id
  storage.free_ids[#storage.free_ids+1] = id

  -- increment free id lenght
  storage.free_ids_len = storage.free_ids_len + 1
end

--

function Storage:new_entry(new_entry_content: value): Id
  return new_entry(self, new_entry_content)
end

function Storage:get_entry(id: Id): Entry
  return get_entry(self, id)
end

function Storage:kill_entry(id:Id)
  kill_entry(self, id)
end

function Storage:delete_dead_entries(): boolean
  return delete_dead_entries(self)
end

function Storage:delete_entry(id: Id)
  delete_entry(self, id)
end
